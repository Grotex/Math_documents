# 加快发现素数的技巧

寻找大素数在有关编码（包括密码）的问题中都有应用，如RSA密码系统、伪随机数生成（有一种“二次剩余序列”，只需4k+3型的素数即可构造出来）、哈希函数的设计等。

可是在茫茫数海中找出素数，并不是很容易的。因为根据素数定理，任意一个不超过x的正整数为素数的概率大致为1/ln(x)。

而在应用中我们要找的素数n可能有成千上百位，x显然比n只大不小，这样1/ln(x)将远远小于1，所以说，“任意一个不超过x的正整数为素数”当x很大时是一个小概率事件。

况且当n不具有特殊形式（“特殊形式”的定义比较广泛，其中典型的是指n-1或n+1有相当的一些小素数幂因子）且没有小素数因子时，
对n是否为素数的验证还是比较麻烦的。

那怎么办呢？别慌，办法还是有的，我们可以用一个多项式f(n)生成素数。

根据Bateman–Horn猜想（https://en.wikipedia.org/wiki/Bateman%E2%80%93Horn_conjecture）：

若f(x)为不可约整系数n次多项式，且

（1）f(0),f(1),f(2),f(3),...,f(n-1)互素；

（2）当x为正数时，f(x)恒为正数。

则当x为不超过n的正整数时，f(x)取素数的概率大致为C/ln(n)，其中C为仅与f(x)有关的常数。

我这里举个例子。设f(x)=x^2+1，n=10^6，当x=1,2,...,n时，一共可得素数54110个。所以有：

C/ln(10^6)×10^6≈54110,C≈54110/10^6×ln(10^6)≈0.74755728.

我们可以说f(x)=x^2+1取素数的概率大致为0.74755728/ln(n)。

这个似乎比直接找素数还差啊……但没必要早早放弃。

显然对于不同的f(x)，C一般不同（但是也会有相同的，自己想想就明白了）

那么C>1时，用f(x)生成素数就比直接找划算了。C越大，f(x)生成素数的可能性也越大。

另外，如果f(x)-1或f(x)+1容易因式分解的话，对于日后的验证也有很大帮助。

这里给出一些f(x)作为实例：
（C>3，且f(x)-1都易于因式分解）

51(x^3-x)+1 C=3.41019300

168(x^3-x)+1 C=3.42958997

800(x^3-x)+1 C=3.14662069
